<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Stamp Folding Visualizer</title>
		<style>
			body {
				font-family: sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				margin: 20px;
			}
			#visualizerSvg {
				border: 1px solid #ccc;
				margin-bottom: 20px;
				display: block; /* Prevents extra space below SVG */
			}
			#sequenceInput {
				width: 300px;
				padding: 8px;
				font-size: 16px;
				box-sizing: border-box;
			}
			label {
				margin-top: 20px;
			}
			#intersectionCountsContainer {
				width: 80%;
				max-width: 300px;
				text-align: left;
			}
			#intersectionCountsContainer ul {
				list-style-type: none;
				padding-left: 0;
			}
			#intersectionCountsContainer li {
				background-color: #f9f9f9;
				border: 1px solid #eee;
				padding: 8px;
				margin-bottom: 5px;
				font-size: 14px;
			}
		</style>
	</head>
	<body>
		<svg id="visualizerSvg"></svg>
		<input type="text" id="sequenceInput" placeholder="3 2 1 6 5 4 9 8 7" />
		<div id="intersectionCountsContainer"></div>

		<script>
			const SVG_NS = "http://www.w3.org/2000/svg";
			const SVG_WIDTH = 300;
			const SVG_PADDING_TOP = 40;
			const SVG_PADDING_BOTTOM = 40;
			const CENTER_X = SVG_WIDTH / 2;
			const Y_SPACING_FACTOR = 25; // Pixels per unit difference in sequence value
			const MIN_Y_VALUE_OFFSET = 1; // Additional spacing for the smallest value from the top

			const CENTERLINE_ARROW_HEAD_SIZE_W = 14;
			const CENTERLINE_ARROW_HEAD_SIZE_H = 10;
			const CROSSING_ARROW_SIZE = 7;
			const RIVER_END_EXTENSION_LENGTH = 60;
			const RIVER_END_ARROW_SIZE = 6;

			const svgElement = document.getElementById("visualizerSvg");
			const sequenceInput = document.getElementById("sequenceInput");

			function createSvgElement(tag, attributes) {
				const el = document.createElementNS(SVG_NS, tag);
				for (const attr in attributes) {
					el.setAttribute(attr, attributes[attr]);
				}
				return el;
			}

			function parseSequence(text) {
				return text
					.trim()
					.split(/\s+/)
					.map((numStr) => parseInt(numStr, 10))
					.filter((num) => !isNaN(num));
			}

			function getMapYForSequence(currentSequence) {
				if (!currentSequence || currentSequence.length === 0) return (val) => val;
				const minVal = Math.min(...currentSequence);
				return (val) => SVG_PADDING_TOP + (val - minVal + MIN_Y_VALUE_OFFSET) * Y_SPACING_FACTOR;
			}

			function drawVisualization(sequence) {
				svgElement.innerHTML = ""; // Clear previous SVG content

				if (!sequence || sequence.length === 0) {
					svgElement.setAttribute("height", SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50); // Default small height
					svgElement.setAttribute("width", SVG_WIDTH);
					return;
				}

				const mapY = getMapYForSequence(sequence);
				const yCoords = sequence.map(mapY);

				let svgHeight;
				if (yCoords.length > 0) {
					const maxYMapped = Math.max(...yCoords);
					svgHeight = maxYMapped + Y_SPACING_FACTOR + SVG_PADDING_BOTTOM;
				} else {
					svgHeight = SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50;
				}
				if (sequence.length === 1 && yCoords.length > 0) {
					// Check yCoords.length too
					svgHeight = yCoords[0] + Y_SPACING_FACTOR + SVG_PADDING_BOTTOM;
				}
				svgHeight = Math.max(svgHeight, SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50);

				svgElement.setAttribute("width", SVG_WIDTH);
				svgElement.setAttribute("height", svgHeight);

				const lineTopY = SVG_PADDING_TOP / 2;
				const lineBottomY = svgHeight - SVG_PADDING_BOTTOM / 2;

				// Draw Centerline
				const centerline = createSvgElement("line", {
					x1: CENTER_X,
					y1: lineTopY,
					x2: CENTER_X,
					y2: lineBottomY,
					stroke: "black",
					"stroke-width": 2,
				});
				svgElement.appendChild(centerline);

				// Draw Top Centerline Arrowhead (downward-facing)
				const topArrowPath = `
			                 M ${CENTER_X - CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineTopY}
			                 L ${CENTER_X + CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineTopY}
			                 L ${CENTER_X},${lineTopY + CENTERLINE_ARROW_HEAD_SIZE_H}`;
				const topArrow = createSvgElement("path", {
					d: topArrowPath,
					fill: "black",
				});
				svgElement.appendChild(topArrow);

				// Draw Bottom Centerline Arrowhead (downward-facing)
				const bottomArrowPath = `
			                 M ${CENTER_X - CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineBottomY - CENTERLINE_ARROW_HEAD_SIZE_H}
			                 L ${CENTER_X + CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineBottomY - CENTERLINE_ARROW_HEAD_SIZE_H}
			                 L ${CENTER_X},${lineBottomY}`;
				const bottomArrow = createSvgElement("path", {
					d: bottomArrowPath,
					fill: "black",
				});
				svgElement.appendChild(bottomArrow);

				if (sequence.length === 0) return;

				// Draw Start of River
				const firstY = mapY(sequence[0]);
				const startRiverX = CENTER_X - RIVER_END_EXTENSION_LENGTH;
				const startRiverLine = createSvgElement("line", {
					x1: startRiverX,
					y1: firstY,
					x2: CENTER_X,
					y2: firstY,
					stroke: "dodgerblue",
					"stroke-width": 2,
				});
				svgElement.appendChild(startRiverLine);

				// Corrected startRiverArrowPath to point right (>)
				const startRiverArrowPath = `
			                 M ${startRiverX - RIVER_END_ARROW_SIZE},${firstY - RIVER_END_ARROW_SIZE}
			                 L ${startRiverX},${firstY}
			                 L ${startRiverX - RIVER_END_ARROW_SIZE},${firstY + RIVER_END_ARROW_SIZE}`;
				const startRiverArrow = createSvgElement("path", {
					d: startRiverArrowPath,
					stroke: "black",
					"stroke-width": 2,
					fill: "none",
				});
				svgElement.appendChild(startRiverArrow);

				// Draw Crossings and Arcs
				for (let i = 0; i < sequence.length; i++) {
					const yPos = mapY(sequence[i]);

					// Draw Crossing Arrow
					const isLeftToRight = i % 2 === 0; // River starts on left, 0th crossing is L->R
					let crossingArrowPath;
					if (isLeftToRight) {
						// Points right (>)
						crossingArrowPath = `
			                         M ${CENTER_X - CROSSING_ARROW_SIZE},${yPos - CROSSING_ARROW_SIZE}
			                         L ${CENTER_X},${yPos}
			                         L ${CENTER_X - CROSSING_ARROW_SIZE},${yPos + CROSSING_ARROW_SIZE}`;
					} else {
						// Points left (<)
						crossingArrowPath = `
			                     M ${CENTER_X + CROSSING_ARROW_SIZE},${yPos - CROSSING_ARROW_SIZE}
			                     L ${CENTER_X},${yPos}
			                     L ${CENTER_X + CROSSING_ARROW_SIZE},${yPos + CROSSING_ARROW_SIZE}`;
					}
					const crossingArrow = createSvgElement("path", {
						d: crossingArrowPath,
						stroke: "black",
						"stroke-width": 1.5,
						fill: "none",
					});
					svgElement.appendChild(crossingArrow);

					// Draw Arc to previous point
					if (i > 0) {
						const prevVal = sequence[i - 1];
						const prevYPos = mapY(prevVal);

						if (prevYPos === yPos) continue; // Skip arc if no vertical distance

						const arcRadius = Math.abs(yPos - prevYPos) / 2;
						if (arcRadius === 0) continue;

						const arcOnRightSide = (i - 1) % 2 === 0;

						let sweepFlag;
						if (arcOnRightSide) {
							sweepFlag = yPos > prevYPos ? 1 : 0;
						} else {
							sweepFlag = yPos > prevYPos ? 0 : 1;
						}

						const arcPath = `
			                         M ${CENTER_X},${prevYPos}
			                         A ${arcRadius},${arcRadius} 0 0,${sweepFlag} ${CENTER_X},${yPos}`;
						const arc = createSvgElement("path", {
							d: arcPath,
							stroke: "dodgerblue",
							"stroke-width": 2,
							fill: "none",
						});
						svgElement.appendChild(arc);
					}
				}

				if (sequence.length > 0) {
					const lastY = mapY(sequence[sequence.length - 1]);
					const lastCrossingIndex = sequence.length - 1;
					const riverEndsOnRight = lastCrossingIndex % 2 === 0; // After L->R crossing, river is on right

					let endRiverX, endRiverArrowPath;
					if (riverEndsOnRight) {
						endRiverX = CENTER_X + RIVER_END_EXTENSION_LENGTH;
						endRiverArrowPath = `
			                         M ${endRiverX - RIVER_END_ARROW_SIZE},${lastY - RIVER_END_ARROW_SIZE}
			                         L ${endRiverX},${lastY}
			                         L ${endRiverX - RIVER_END_ARROW_SIZE},${lastY + RIVER_END_ARROW_SIZE}`;
					} else {
						endRiverX = CENTER_X - RIVER_END_EXTENSION_LENGTH;
						endRiverArrowPath = `
			                         M ${endRiverX + RIVER_END_ARROW_SIZE},${lastY - RIVER_END_ARROW_SIZE}
			                         L ${endRiverX},${lastY}
			                         L ${endRiverX + RIVER_END_ARROW_SIZE},${lastY + RIVER_END_ARROW_SIZE}`;
					}

					// Draw End of River
					const endRiverLine = createSvgElement("line", {
						x1: CENTER_X,
						y1: lastY,
						x2: endRiverX,
						y2: lastY,
						stroke: "dodgerblue",
						"stroke-width": 2,
					});
					svgElement.appendChild(endRiverLine);

					// Draw End of River Arrow
					const endRiverArrow = createSvgElement("path", {
						d: endRiverArrowPath,
						stroke: "black",
						"stroke-width": 2,
						fill: "none",
					});
					svgElement.appendChild(endRiverArrow);
				}
			}

			// Procedure to count intersections bounding a sub-region surrounded by the road and river bends
			// For every bend:
			// 	Position = top of the bend
			// 	Counter = 1
			// 	Loop until done:
			// 		Travel 1 down the road and add 1
			// 		Are we at the bottom of our bend?
			// 			Yes -> exit to continue on to the next bend
			// 			No -> Are we at the top of another bend on our same side?
			// 				Yes -> follow it, add 1, then continue the inner loop
			// 				No -> continue the inner loop
			function countIntersectionsForArc(sequence, outerBendA, outerBendB) {
				const pairTopAndBottom = (a, b) => [Math.min(a, b), Math.max(a, b)];
				const getSide = (index) => (index % 2 === 0 ? "right" : "left");

				const bendPairs = sequence.slice(0, -1).map((_, i) => ({
					a: sequence[i],
					b: sequence[i + 1],
					side: getSide(i),
				}));

				const [outerBendTop, outerBendBottom] = pairTopAndBottom(outerBendA, outerBendB);
				const outerIsLeft = bendPairs.find(({ a, b }) => {
					const [top, bottom] = pairTopAndBottom(a, b);
					return top === outerBendTop && bottom === outerBendBottom;
				}).side;

				let position = outerBendTop;
				let count = 1;

				while (true) {
					position += 1;
					count += 1;

					if (position === outerBendBottom) break; // Reached the bottom of the bend

					const nextBend = bendPairs.find(({ a, b, side }) => position === pairTopAndBottom(a, b)[0] && side === outerIsLeft);

					if (nextBend) {
						const [nextBendTop, nextBendBottom] = pairTopAndBottom(nextBend.a, nextBend.b);
						count += 1; // Count the bend
						position = nextBendBottom; // Follow the bend to its bottom
					}
				}

				return count;
			}

			function displayIntersectionCounts(sequence) {
				const countsElement = document.getElementById("intersectionCountsContainer");
				countsElement.innerHTML = "";

				if (!sequence || sequence.length < 2) return;

				const bendList = [];

				for (let i = 1; i < sequence.length; i++) {
					const yPrev = sequence[i - 1];
					const yCurr = sequence[i];
					if (yPrev === yCurr) continue;

					const count = countIntersectionsForArc(sequence, yPrev, yCurr);
					const side = (i - 1) % 2 === 0 ? "right" : "left";

					const li = document.createElement("li");
					li.textContent = `${count} corners: ${side} side bend from ${yPrev} to ${yCurr}`;
					bendList.push(li);
				}

				if (bendList.length > 0) {
					const ul = document.createElement("ul");
					bendList.forEach((li) => ul.appendChild(li));
					countsElement.appendChild(ul);
				}
			}

			function handleInputChange() {
				const sequenceText = sequenceInput.value;
				const sequence = parseSequence(sequenceText);
				drawVisualization(sequence);
				displayIntersectionCounts(sequence);
			}

			sequenceInput.addEventListener("input", handleInputChange);

			sequenceInput.value = "3 2 1 6 5 4 9 8 7";
			handleInputChange();
		</script>
	</body>
</html>
