<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Stamp Folding Visualizer</title>
		<style>
			body {
				font-family: sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				margin: 20px;
			}
			#visualizerSvg {
				border: 1px solid #ccc;
				margin-bottom: 20px;
				display: block; /* Prevents extra space below SVG */
			}
			#sequenceInput {
				width: 300px;
				padding: 8px;
				font-size: 16px;
				margin-top: 10px;
			}
			label {
				margin-top: 20px;
			}
		</style>
	</head>
	<body>
		<svg id="visualizerSvg"></svg>
		<input type="text" id="sequenceInput" placeholder="3 2 1 6 5 4 9 8 7" />

		<script>
			const SVG_NS = "http://www.w3.org/2000/svg";
			const SVG_WIDTH = 400;
			const SVG_PADDING_TOP = 40;
			const SVG_PADDING_BOTTOM = 40;
			const CENTER_X = SVG_WIDTH / 2;
			const Y_SPACING_FACTOR = 25; // Pixels per unit difference in sequence value
			const MIN_Y_VALUE_OFFSET = 1; // Additional spacing for the smallest value from the top

			const CENTERLINE_ARROW_HEAD_SIZE_W = 14;
			const CENTERLINE_ARROW_HEAD_SIZE_H = 10;
			const CROSSING_ARROW_SIZE = 7;
			const RIVER_END_EXTENSION_LENGTH = 60;
			const RIVER_END_ARROW_SIZE = 6;

			const svgElement = document.getElementById("visualizerSvg");
			const sequenceInput = document.getElementById("sequenceInput");

			function createSvgElement(tag, attributes) {
				const el = document.createElementNS(SVG_NS, tag);
				for (const attr in attributes) {
					el.setAttribute(attr, attributes[attr]);
				}
				return el;
			}

			function parseSequence(text) {
				return text
					.trim()
					.split(/\s+/)
					.map((numStr) => parseInt(numStr, 10))
					.filter((num) => !isNaN(num));
			}

			function getMapYForSequence(currentSequence) {
				if (!currentSequence || currentSequence.length === 0) return (val) => val;
				const minVal = Math.min(...currentSequence);
				return (val) => SVG_PADDING_TOP + (val - minVal + MIN_Y_VALUE_OFFSET) * Y_SPACING_FACTOR;
			}

			function drawVisualization(sequence) {
				svgElement.innerHTML = ""; // Clear previous SVG content

				if (!sequence || sequence.length === 0) {
					svgElement.setAttribute("height", SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50); // Default small height
					svgElement.setAttribute("width", SVG_WIDTH);
					return;
				}

				const mapY = getMapYForSequence(sequence);
				const yCoords = sequence.map(mapY);

				let svgHeight;
				if (yCoords.length > 0) {
					const maxYMapped = Math.max(...yCoords);
					svgHeight = maxYMapped + Y_SPACING_FACTOR + SVG_PADDING_BOTTOM;
				} else {
					svgHeight = SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50;
				}
				if (sequence.length === 1 && yCoords.length > 0) {
					// Check yCoords.length too
					svgHeight = yCoords[0] + Y_SPACING_FACTOR + SVG_PADDING_BOTTOM;
				}
				svgHeight = Math.max(svgHeight, SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50);

				svgElement.setAttribute("width", SVG_WIDTH);
				svgElement.setAttribute("height", svgHeight);

				const lineTopY = SVG_PADDING_TOP / 2;
				const lineBottomY = svgHeight - SVG_PADDING_BOTTOM / 2;

				// Draw Centerline
				const centerline = createSvgElement("line", {
					x1: CENTER_X,
					y1: lineTopY,
					x2: CENTER_X,
					y2: lineBottomY,
					stroke: "black",
					"stroke-width": 2,
				});
				svgElement.appendChild(centerline);

				// Draw Top Centerline Arrowhead (downward-facing)
				const topArrowPath = `
					M ${CENTER_X - CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineTopY}
					L ${CENTER_X + CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineTopY}
					L ${CENTER_X},${lineTopY + CENTERLINE_ARROW_HEAD_SIZE_H}`;
				const topArrow = createSvgElement("path", {
					d: topArrowPath,
					fill: "black",
				});
				svgElement.appendChild(topArrow);

				// Draw Bottom Centerline Arrowhead (downward-facing)
				const bottomArrowPath = `
					M ${CENTER_X - CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineBottomY - CENTERLINE_ARROW_HEAD_SIZE_H}
					L ${CENTER_X + CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineBottomY - CENTERLINE_ARROW_HEAD_SIZE_H}
					L ${CENTER_X},${lineBottomY}`;
				const bottomArrow = createSvgElement("path", {
					d: bottomArrowPath,
					fill: "black",
				});
				svgElement.appendChild(bottomArrow);

				if (sequence.length === 0) return;

				// Draw Start of River
				const firstY = mapY(sequence[0]);
				const startRiverX = CENTER_X - RIVER_END_EXTENSION_LENGTH;
				const startRiverLine = createSvgElement("line", {
					x1: startRiverX,
					y1: firstY,
					x2: CENTER_X,
					y2: firstY,
					stroke: "dodgerblue",
					"stroke-width": 2,
				});
				svgElement.appendChild(startRiverLine);

				// Corrected startRiverArrowPath to point right (>)
				const startRiverArrowPath = `
					M ${startRiverX - RIVER_END_ARROW_SIZE},${firstY - RIVER_END_ARROW_SIZE}
					L ${startRiverX},${firstY}
					L ${startRiverX - RIVER_END_ARROW_SIZE},${firstY + RIVER_END_ARROW_SIZE}`;
				const startRiverArrow = createSvgElement("path", {
					d: startRiverArrowPath,
					stroke: "black",
					"stroke-width": 2,
					fill: "none",
				});
				svgElement.appendChild(startRiverArrow);

				// Draw Crossings and Arcs
				for (let i = 0; i < sequence.length; i++) {
					const yPos = mapY(sequence[i]);

					// Draw Crossing Arrow
					const isLeftToRight = i % 2 === 0; // River starts on left, 0th crossing is L->R
					let crossingArrowPath;
					if (isLeftToRight) {
						// Points right (>)
						crossingArrowPath = `
							M ${CENTER_X - CROSSING_ARROW_SIZE},${yPos - CROSSING_ARROW_SIZE}
							L ${CENTER_X},${yPos}
							L ${CENTER_X - CROSSING_ARROW_SIZE},${yPos + CROSSING_ARROW_SIZE}`;
					} else {
						// Points left (<)
						crossingArrowPath = `
						M ${CENTER_X + CROSSING_ARROW_SIZE},${yPos - CROSSING_ARROW_SIZE}
						L ${CENTER_X},${yPos}
						L ${CENTER_X + CROSSING_ARROW_SIZE},${yPos + CROSSING_ARROW_SIZE}`;
					}
					const crossingArrow = createSvgElement("path", {
						d: crossingArrowPath,
						stroke: "black",
						"stroke-width": 1.5,
						fill: "none",
					});
					svgElement.appendChild(crossingArrow);

					// Draw Arc to previous point
					if (i > 0) {
						const prevVal = sequence[i - 1];
						const prevYPos = mapY(prevVal);

						if (prevYPos === yPos) continue; // Skip arc if no vertical distance

						const arcRadius = Math.abs(yPos - prevYPos) / 2;
						if (arcRadius === 0) continue;

						const arcOnRightSide = (i - 1) % 2 === 0;

						let sweepFlag;
						if (arcOnRightSide) {
							sweepFlag = yPos > prevYPos ? 1 : 0;
						} else {
							sweepFlag = yPos > prevYPos ? 0 : 1;
						}

						const arcPath = `
							M ${CENTER_X},${prevYPos}
							A ${arcRadius},${arcRadius} 0 0,${sweepFlag} ${CENTER_X},${yPos}`;
						const arc = createSvgElement("path", {
							d: arcPath,
							stroke: "dodgerblue",
							"stroke-width": 2,
							fill: "none",
						});
						svgElement.appendChild(arc);
					}
				}

				if (sequence.length > 0) {
					const lastY = mapY(sequence[sequence.length - 1]);
					const lastCrossingIndex = sequence.length - 1;
					const riverEndsOnRight = lastCrossingIndex % 2 === 0; // After L->R crossing, river is on right

					let endRiverX, endRiverArrowPath;
					if (riverEndsOnRight) {
						endRiverX = CENTER_X + RIVER_END_EXTENSION_LENGTH;
						endRiverArrowPath = `
						M ${endRiverX - RIVER_END_ARROW_SIZE},${lastY - RIVER_END_ARROW_SIZE}
						L ${endRiverX},${lastY}
						L ${endRiverX - RIVER_END_ARROW_SIZE},${lastY + RIVER_END_ARROW_SIZE}`;
					} else {
						endRiverX = CENTER_X - RIVER_END_EXTENSION_LENGTH;
						endRiverArrowPath = `
                            M ${endRiverX + RIVER_END_ARROW_SIZE},${lastY - RIVER_END_ARROW_SIZE}
                            L ${endRiverX},${lastY}
                            L ${endRiverX + RIVER_END_ARROW_SIZE},${lastY + RIVER_END_ARROW_SIZE}`;
					}

					// Draw End of River
					const endRiverLine = createSvgElement("line", {
						x1: CENTER_X,
						y1: lastY,
						x2: endRiverX,
						y2: lastY,
						stroke: "dodgerblue",
						"stroke-width": 2,
					});
					svgElement.appendChild(endRiverLine);

					// Draw End of River Arrow
					const endRiverArrow = createSvgElement("path", {
						d: endRiverArrowPath,
						stroke: "black",
						"stroke-width": 2,
						fill: "none",
					});
					svgElement.appendChild(endRiverArrow);
				}
			}

			function handleInputChange() {
				const sequenceText = sequenceInput.value;
				const sequence = parseSequence(sequenceText);
				drawVisualization(sequence);
			}

			sequenceInput.addEventListener("input", handleInputChange);

			sequenceInput.value = "3 2 1 6 5 4 9 8 7";
			handleInputChange();
		</script>
	</body>
</html>
