<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Stamp Folding Visualizer</title>
		<style>
			body {
				font-family: sans-serif;
				display: flex;
				flex-direction: column;
				align-items: center;
				margin: 20px;
			}
			#visualizerSvg {
				border: 1px solid #ccc;
				margin-bottom: 20px;
				display: block; /* Prevents extra space below SVG */
			}
			#sequenceInput {
				width: 300px;
				padding: 8px;
				font-size: 16px;
				box-sizing: border-box;
			}
			label {
				margin-top: 20px;
			}
			#intersectionCountsContainer {
				width: 80%;
				max-width: 300px;
				text-align: left;
			}
			#intersectionCountsContainer ul {
				list-style-type: none;
				padding-left: 0;
			}
			#intersectionCountsContainer li {
				background-color: #f9f9f9;
				border: 1px solid #eee;
				padding: 8px;
				margin-bottom: 5px;
				font-size: 14px;
			}
		</style>
	</head>
	<body>
		<svg id="visualizerSvg"></svg>
		<input type="text" id="sequenceInput" placeholder="3 2 1 6 5 4 9 8 7" />
		<div id="intersectionCountsContainer"></div>

		<script>
			const SVG_NS = "http://www.w3.org/2000/svg";
			const SVG_WIDTH = 300;
			const SVG_PADDING_TOP = 40;
			const SVG_PADDING_BOTTOM = 40;
			const CENTER_X = SVG_WIDTH / 2;
			const Y_SPACING_FACTOR = 25; // Pixels per unit difference in sequence value
			const MIN_Y_VALUE_OFFSET = 1; // Additional spacing for the smallest value from the top

			const CENTERLINE_ARROW_HEAD_SIZE_W = 14;
			const CENTERLINE_ARROW_HEAD_SIZE_H = 10;
			const CROSSING_ARROW_SIZE = 7;
			const RIVER_END_EXTENSION_LENGTH = 60;
			const RIVER_END_ARROW_SIZE = 6;

			const svgElement = document.getElementById("visualizerSvg");
			const sequenceInput = document.getElementById("sequenceInput");

			function createSvgElement(tag, attributes, tooltip) {
				const el = document.createElementNS(SVG_NS, tag);
				for (const attr in attributes) {
					el.setAttribute(attr, attributes[attr]);
				}
				if (tooltip) {
					const title = document.createElementNS(SVG_NS, "title");
					title.textContent = tooltip;
					el.appendChild(title);
				}
				return el;
			}

			function parseSequence(text) {
				return text
					.trim()
					.split(/\s+/)
					.map((numStr) => parseInt(numStr, 10))
					.filter((num) => !isNaN(num));
			}

			function getMapYForSequence(currentSequence) {
				if (!currentSequence || currentSequence.length === 0) return (val) => val;
				const minVal = Math.min(...currentSequence);
				return (val) => SVG_PADDING_TOP + (val - minVal + MIN_Y_VALUE_OFFSET) * Y_SPACING_FACTOR;
			}

			// Helper function to determine if an arc is on the left or right side
			// based on the index of its starting point in the sequence.
			function getSide(arcStartingIndexInSequence) {
				return arcStartingIndexInSequence % 2 === 0 ? "right" : "left";
			}

			function drawVisualization(sequence) {
				svgElement.innerHTML = ""; // Clear previous SVG content

				if (!sequence || sequence.length === 0) {
					svgElement.setAttribute("height", SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50);
					svgElement.setAttribute("width", SVG_WIDTH);
					return;
				}

				const mapY = getMapYForSequence(sequence);
				const yCoords = sequence.map(mapY);

				let svgHeight;
				if (yCoords.length > 0) {
					const maxYMapped = Math.max(...yCoords);
					svgHeight = maxYMapped + Y_SPACING_FACTOR + SVG_PADDING_BOTTOM;
				} else {
					svgHeight = SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50;
				}
				if (sequence.length === 1 && yCoords.length > 0) {
					svgHeight = yCoords[0] + Y_SPACING_FACTOR + SVG_PADDING_BOTTOM;
				}
				svgHeight = Math.max(svgHeight, SVG_PADDING_TOP + SVG_PADDING_BOTTOM + 50);

				svgElement.setAttribute("width", SVG_WIDTH);
				svgElement.setAttribute("height", svgHeight);

				// Create a group for filled regions, add it first so it's in the background
				const fillsGroup = createSvgElement("g", {});
				svgElement.appendChild(fillsGroup);

				// Draw Region Fills
				if (sequence.length >= 2) {
					for (let i = 0; i < sequence.length - 1; i++) {
						let { drawingPositions, drawingDirections } = generateRegionFilledPaths(sequence, sequence[i], sequence[i + 1]);
						drawingPositions.push(drawingPositions[0]);
						drawingDirections.push(drawingDirections[0]);
						const intersectionCount = countIntersectionsForArc(sequence, sequence[i], sequence[i + 1]);
						const fillColor =
							{
								2: "yellow",
								3: "orange",
								4: "red",
							}[intersectionCount] || "darkgray";

						let startY = mapY(drawingPositions[0]);
						let closeDirection = drawingDirections[0];
						let pathData = `M ${CENTER_X},${startY}`;
						if (intersectionCount === 6 && i === 2) console.log(`drawingPositions[0]: ${drawingPositions[0]}, startY: ${startY}`);

						for (let j = 1; j < drawingPositions.length; j++) {
							const nextY = mapY(drawingPositions[j]);
							if (intersectionCount === 6 && i === 2) console.log(`drawingPositions[${j}]: ${drawingPositions[j]}, nextY: ${nextY}`);
							const direction = drawingDirections[j];

							const directionFlag = (j === drawingPositions.length - 1) !== (direction === "right") ? 1 : 0;

							if (direction === "down") pathData += ` L ${CENTER_X},${nextY}`;
							else pathData += ` A 1,1 0 0,${directionFlag} ${CENTER_X},${nextY}`;
						}

						const fillPath = createSvgElement(
							"path",
							{
								d: pathData,
								fill: fillColor,
								stroke: "none",
							},
							`${intersectionCount} corner region`
						);
						fillsGroup.appendChild(fillPath);
					}
				}

				const lineTopY = SVG_PADDING_TOP / 2;
				const lineBottomY = svgHeight - SVG_PADDING_BOTTOM / 2;

				// Draw Centerline
				const centerlineElement = createSvgElement("line", {
					x1: CENTER_X,
					y1: lineTopY,
					x2: CENTER_X,
					y2: lineBottomY,
					stroke: "black",
					"stroke-width": 2,
				});
				svgElement.appendChild(centerlineElement);

				// Draw Top Centerline Arrowhead (downward-facing)
				const topArrowPath = `
					M ${CENTER_X - CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineTopY}
					L ${CENTER_X + CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineTopY}
					L ${CENTER_X},${lineTopY + CENTERLINE_ARROW_HEAD_SIZE_H}`.trim();
				const topArrow = createSvgElement("path", {
					d: topArrowPath,
					fill: "black",
				});
				svgElement.appendChild(topArrow);

				// Draw Bottom Centerline Arrowhead (downward-facing)
				const bottomArrowPath = `
					M ${CENTER_X - CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineBottomY - CENTERLINE_ARROW_HEAD_SIZE_H}
					L ${CENTER_X + CENTERLINE_ARROW_HEAD_SIZE_W / 2},${lineBottomY - CENTERLINE_ARROW_HEAD_SIZE_H}
					L ${CENTER_X},${lineBottomY}`
					.replace(/\t+/g, " ")
					.trim();
				const bottomArrow = createSvgElement("path", {
					d: bottomArrowPath,
					fill: "black",
				});
				svgElement.appendChild(bottomArrow);

				if (sequence.length === 0) return;

				// Draw Start of River
				const firstY = mapY(sequence[0]);
				const startRiverX = CENTER_X - RIVER_END_EXTENSION_LENGTH;
				const startRiverLine = createSvgElement("line", {
					x1: startRiverX,
					y1: firstY,
					x2: CENTER_X,
					y2: firstY,
					stroke: "dodgerblue",
					"stroke-width": 2,
				});
				svgElement.appendChild(startRiverLine);

				// Corrected startRiverArrowPath to point right (>)
				const startRiverArrowPath = `
					M ${startRiverX - RIVER_END_ARROW_SIZE},${firstY - RIVER_END_ARROW_SIZE}
					L ${startRiverX},${firstY}
					L ${startRiverX - RIVER_END_ARROW_SIZE},${firstY + RIVER_END_ARROW_SIZE}`
					.replace(/\t+/g, " ")
					.trim();
				const startRiverArrow = createSvgElement("path", {
					d: startRiverArrowPath,
					stroke: "black",
					"stroke-width": 2,
					fill: "none",
				});
				svgElement.appendChild(startRiverArrow);

				// Draw crossings and arcs (river path)
				for (let i = 0; i < sequence.length; i++) {
					const yPos = mapY(sequence[i]);

					// Draw Crossing Arrow
					let crossingArrowPath;
					if (getSide(i) === "right") {
						// Points right (>)
						crossingArrowPath = `
							M ${CENTER_X - CROSSING_ARROW_SIZE},${yPos - CROSSING_ARROW_SIZE}
							L ${CENTER_X},${yPos}
							L ${CENTER_X - CROSSING_ARROW_SIZE},${yPos + CROSSING_ARROW_SIZE}`
							.replace(/\t+/g, " ")
							.trim();
					} else {
						// Points left (<)
						crossingArrowPath = `
							M ${CENTER_X + CROSSING_ARROW_SIZE},${yPos - CROSSING_ARROW_SIZE}
							L ${CENTER_X},${yPos}
							L ${CENTER_X + CROSSING_ARROW_SIZE},${yPos + CROSSING_ARROW_SIZE}`
							.replace(/\t+/g, " ")
							.trim();
					}
					const crossingArrow = createSvgElement("path", {
						d: crossingArrowPath,
						stroke: "black",
						"stroke-width": 1.5,
						fill: "none",
					});
					svgElement.appendChild(crossingArrow);

					// Draw Arc to previous point
					if (i > 0) {
						const prevVal = sequence[i - 1];
						const prevYPos = mapY(prevVal);

						if (prevYPos === yPos) continue; // Skip arc if no vertical distance

						const arcRadius = Math.abs(yPos - prevYPos) / 2;
						if (arcRadius === 0) continue;

						const arcSide = getSide(i - 1);

						let sweepFlag;
						if (arcSide === "right") {
							sweepFlag = yPos > prevYPos ? 1 : 0;
						} else {
							sweepFlag = yPos > prevYPos ? 0 : 1;
						}

						const arcPath = `
							M ${CENTER_X},${prevYPos}
							A ${arcRadius},${arcRadius} 0 0,${sweepFlag} ${CENTER_X},${yPos}`
							.replace(/\t+/g, " ")
							.trim();
						const arc = createSvgElement("path", {
							d: arcPath,
							stroke: "dodgerblue",
							"stroke-width": 2,
							fill: "none",
						});
						svgElement.appendChild(arc);
					}
				}

				if (sequence.length > 0) {
					const lastY = mapY(sequence[sequence.length - 1]);
					const lastCrossingIndex = sequence.length - 1;
					// Side of the river after the last crossing: if last crossing L->R (index even), river is on right.
					const riverEndsOnSide = getSide(lastCrossingIndex);

					let endRiverX, endRiverArrowPath;
					if (riverEndsOnSide === "right") {
						// River is on the right side of centerline, arrow points right
						endRiverX = CENTER_X + RIVER_END_EXTENSION_LENGTH;
						endRiverArrowPath = `
							M ${endRiverX - RIVER_END_ARROW_SIZE},${lastY - RIVER_END_ARROW_SIZE}
							L ${endRiverX},${lastY}
							L ${endRiverX - RIVER_END_ARROW_SIZE},${lastY + RIVER_END_ARROW_SIZE}`
							.replace(/\t+/g, " ")
							.trim();
					} else {
						// River is on the left side of centerline, arrow points left
						endRiverX = CENTER_X - RIVER_END_EXTENSION_LENGTH;
						endRiverArrowPath = `
							M ${endRiverX + RIVER_END_ARROW_SIZE},${lastY - RIVER_END_ARROW_SIZE}
							L ${endRiverX},${lastY}
							L ${endRiverX + RIVER_END_ARROW_SIZE},${lastY + RIVER_END_ARROW_SIZE}`
							.replace(/\t+/g, " ")
							.trim();
					}

					// Draw End of River
					const endRiverLine = createSvgElement("line", {
						x1: CENTER_X,
						y1: lastY,
						x2: endRiverX,
						y2: lastY,
						stroke: "dodgerblue",
						"stroke-width": 2,
					});
					svgElement.appendChild(endRiverLine);

					// Draw End of River Arrow
					const endRiverArrow = createSvgElement("path", {
						d: endRiverArrowPath,
						stroke: "black",
						"stroke-width": 2,
						fill: "none",
					});
					svgElement.appendChild(endRiverArrow);
				}
			}

			// Procedure to count intersections bounding a sub-region surrounded by the road and river bends
			// For every bend:
			// 	Position = top of the bend
			// 	Counter = 1
			// 	Loop until done:
			// 		Travel 1 down the road and add 1
			// 		Are we at the bottom of our bend?
			// 			Yes -> exit to continue on to the next bend
			// 			No -> Are we at the top of another bend on our same side?
			// 				Yes -> follow it, add 1, then continue the inner loop
			// 				No -> continue the inner loop
			function countIntersectionsForArc(sequence, outerBendA, outerBendB) {
				const pairTopAndBottom = (a, b) => [Math.min(a, b), Math.max(a, b)];

				const bendPairs = sequence.slice(0, -1).map((_, i) => ({
					a: sequence[i],
					b: sequence[i + 1],
					side: getSide(i),
				}));

				const [outerBendTop, outerBendBottom] = pairTopAndBottom(outerBendA, outerBendB);
				const outerSide = bendPairs.find(({ a, b }) => {
					const [top, bottom] = pairTopAndBottom(a, b);
					return top === outerBendTop && bottom === outerBendBottom;
				}).side;

				let position = outerBendTop;
				let count = 1;

				while (true) {
					position += 1;
					count += 1;

					if (position === outerBendBottom) break; // Reached the bottom of the bend

					const nextBend = bendPairs.find(({ a, b, side }) => position === pairTopAndBottom(a, b)[0] && side === outerSide);

					if (nextBend) {
						const [nextBendTop, nextBendBottom] = pairTopAndBottom(nextBend.a, nextBend.b);
						count += 1; // Count the bend
						position = nextBendBottom; // Follow the bend to its bottom
					}
				}

				return count;
			}

			function generateRegionFilledPaths(sequence, outerBendA, outerBendB) {
				const pairTopAndBottom = (a, b) => [Math.min(a, b), Math.max(a, b)];

				const bendPairs = sequence.slice(0, -1).map((_, i) => ({
					a: sequence[i],
					b: sequence[i + 1],
					side: getSide(i),
				}));

				const [outerBendTop, outerBendBottom] = pairTopAndBottom(outerBendA, outerBendB);
				const outerSide = bendPairs.find(({ a, b }) => {
					const [top, bottom] = pairTopAndBottom(a, b);
					return top === outerBendTop && bottom === outerBendBottom;
				}).side;

				let position = outerBendTop;
				let drawingPositions = [outerBendTop];
				let drawingDirections = [outerSide];

				while (true) {
					position += 1;
					drawingPositions.push(position);
					drawingDirections.push("down");

					if (position === outerBendBottom) break; // Reached the bottom of the bend

					const nextBend = bendPairs.find(({ a, b, side }) => position === pairTopAndBottom(a, b)[0] && side === outerSide);

					if (nextBend) {
						const [nextBendTop, nextBendBottom] = pairTopAndBottom(nextBend.a, nextBend.b);
						position = nextBendBottom; // Follow the bend to its bottom
						drawingPositions.push(position);
						drawingDirections.push(nextBend.side); // Count the bend
					}
				}

				return { drawingPositions, drawingDirections };
			}

			function displayIntersectionCounts(sequence) {
				const countsElement = document.getElementById("intersectionCountsContainer");
				countsElement.innerHTML = "";

				if (!sequence || sequence.length < 2) return;

				const bendList = [];

				for (let i = 1; i < sequence.length; i++) {
					const yPrev = sequence[i - 1];
					const yCurr = sequence[i];
					if (yPrev === yCurr) continue;

					const count = countIntersectionsForArc(sequence, yPrev, yCurr);
					const side = getSide(i - 1);

					const li = document.createElement("li");
					li.textContent = `${count} corners: ${side} side bend from ${yPrev} to ${yCurr}`;
					bendList.push(li);
				}

				if (bendList.length > 0) {
					const ul = document.createElement("ul");
					bendList.forEach((li) => ul.appendChild(li));
					countsElement.appendChild(ul);
				}
			}

			function handleInputChange() {
				const sequenceText = sequenceInput.value;
				const sequence = parseSequence(sequenceText);
				drawVisualization(sequence);
				displayIntersectionCounts(sequence);
			}

			sequenceInput.addEventListener("input", handleInputChange);

			sequenceInput.value = "3 2 1 6 5 4 9 8 7";
			handleInputChange();
		</script>
	</body>
</html>
